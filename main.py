import asyncio
import logging
import os
import re
from typing import Dict, Optional

from aiogram import Bot
from aiogram.client.default import DefaultBotProperties
from dotenv import load_dotenv
from gcore import Gcore

load_dotenv()

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S"
)
logger = logging.getLogger(__name__)

API_TOKEN = os.getenv("API_TOKEN")
TG_TOKEN = os.getenv("TG_BOT_TOKEN")
CHAT_ID = int(os.getenv("TG_CHAT_ID"))
TOPIC_ID = int(os.getenv("TG_TOPIC_ID")) if os.getenv("TG_TOPIC_ID") else None
CHECK_INTERVAL = int(os.getenv("CHECK_INTERVAL", 30))
REMINDER_INTERVAL = int(os.getenv("REMINDER_INTERVAL", 30))

client = Gcore(api_key=API_TOKEN)
bot = Bot(token=TG_TOKEN, default=DefaultBotProperties(parse_mode="HTML"))

previous_states: Dict[str, int] = {}

LABEL_KV_RE = re.compile(r'(?P<key>[a-zA-Z0-9_]+)="(?P<val>[^"]*)"')
LINE_RE = re.compile(r'^\s*healthcheck_state\{(?P<labels>[^}]*)}\s+(?P<value>[01])\s*$')


def status_icon(value: int) -> str:
    return "üü©" if value == 1 else "üü•"


def status_text(value: int) -> str:
    return f"{status_icon(value)} {'UP' if value == 1 else 'DOWN'}"


def format_item(data: dict, mid: str) -> str:
    return f"<code>{data['ip']}</code> | <code>{data['zone']}</code> | <code>{mid}</code>"


def format_rrset(rrset: str, items: list) -> str:
    return f"<b>{rrset}</b>\n" + "\n".join(items)


def group_by_rrset(parsed: Dict[str, dict], value: Optional[int] = None) -> Dict[str, list]:
    """Group monitors by rrset, optionally filtering by value (0=DOWN, 1=UP)."""
    grouped = {}
    for mid, data in parsed.items():
        if value is not None and data["value"] != value:
            continue
        rrset = data['rrset'] or "unknown"
        item = f"{status_icon(data['value'])} {format_item(data, mid)}"
        grouped.setdefault(rrset, []).append(item)
    return grouped


def parse_metrics(metrics_text: str) -> Dict[str, dict]:
    """Parse Prometheus exposition text for healthcheck_state lines."""
    parsed = {}

    for line in metrics_text.splitlines():
        if not (line := line.strip()) or line.startswith("#"):
            continue

        if not (match := LINE_RE.match(line)):
            continue

        labels = {kv.group("key"): kv.group("val")
                  for kv in LABEL_KV_RE.finditer(match.group("labels"))}

        if not (monitor_id := labels.get("monitor_id")):
            continue

        monitor_name = labels.get("monitor_name", "")
        ip = (ip_match.group(1).strip()
              if (ip_match := re.search(r'Autogenerated monitor for\s+([^,]+)', monitor_name))
              else "")

        parsed[monitor_id] = {
            "ip": ip,
            "rrset": labels.get("rrset_name", ""),
            "zone": labels.get("zone_name", ""),
            "monitor_name": monitor_name,
            "value": int(match.group("value")),
        }

    return parsed


def fetch_metrics() -> Optional[Dict[str, dict]]:
    """Fetch and parse metrics, return None on error."""
    try:
        raw = client.dns.metrics.list()
        return parse_metrics(raw)
    except Exception as e:
        logger.error(f"Error fetching metrics: {e}")
        return None


async def send_message(text: str):
    """Send message to chat, optionally to specific topic."""
    await bot.send_message(CHAT_ID, text, message_thread_id=TOPIC_ID)


async def send_grouped_messages(grouped: Dict[str, list], header: str, rrsets_per_message: int = 2):
    """Send grouped items in chunks."""
    if not grouped:
        return

    total = sum(len(v) for v in grouped.values())
    full_header = f"{header.format(total=total)}\n\n"
    rrsets = sorted(grouped.items())

    for i in range(0, len(rrsets), rrsets_per_message):
        chunk = rrsets[i:i + rrsets_per_message]
        msg = "\n\n".join(format_rrset(r, items) for r, items in chunk)
        if i == 0:
            msg = full_header + msg
        await send_message(msg)


async def send_initial_state(parsed: Dict[str, dict]):
    """Send initial full system state once at startup."""
    await send_message("üöÄ <b>Monitoring Started</b>")

    down_grouped = group_by_rrset(parsed, value=0)
    up_grouped = group_by_rrset(parsed, value=1)

    await send_grouped_messages(down_grouped, "üü• <b>DOWN ({total}):</b>")
    await send_grouped_messages(up_grouped, "üü© <b>UP ({total}):</b>")


async def check_and_notify():
    """Check for state changes and send notifications."""
    global previous_states

    parsed = fetch_metrics()
    if parsed is None:
        return

    for monitor_id, data in parsed.items():
        old_value = previous_states.get(monitor_id)
        new_value = data["value"]

        if old_value is not None and old_value != new_value:
            prev_status = status_text(old_value)
            curr_status = status_text(new_value)

            logger.info(f"State changed: {data['ip']} ({data['rrset']}) {prev_status} -> {curr_status}")

            status_header = "üü© <b>Node Online</b>" if new_value == 1 else "üü• <b>Node Offline</b>"
            text = (
                f"{status_header}\n\n"
                f"<code>{data['ip']}</code> | <code>{data['rrset']}</code>\n"
                f"<code>{data['zone']}</code> | <code>{monitor_id}</code>\n\n"
                f"<b>{prev_status}</b> ‚Üí <b>{curr_status}</b>"
            )

            await send_message(text)

    previous_states = {mid: d["value"] for mid, d in parsed.items()}


async def send_down_reminder():
    """Send periodic reminder about all DOWN healthchecks."""
    parsed = fetch_metrics()
    if parsed is None:
        return

    down_grouped = group_by_rrset(parsed, value=0)

    if not down_grouped:
        logger.info("Reminder: no DOWN healthchecks")
        return

    total = sum(len(v) for v in down_grouped.values())
    logger.info(f"Reminder: {total} DOWN healthchecks")

    lines = [f"‚è∞ <b>DOWN Reminder ({total}):</b>"]
    for rrset, items in sorted(down_grouped.items()):
        lines.append(format_rrset(rrset, items))

    await send_message("\n\n".join(lines))


async def reminder_loop():
    """Periodic reminder loop."""
    while True:
        await asyncio.sleep(REMINDER_INTERVAL * 60)
        await send_down_reminder()


async def check_loop():
    """Main check loop."""
    while True:
        await check_and_notify()
        await asyncio.sleep(CHECK_INTERVAL)


async def main():
    global previous_states

    logger.info("Starting DNS healthcheck monitor")
    logger.info(f"Check interval: {CHECK_INTERVAL}s, Reminder interval: {REMINDER_INTERVAL}m {'(disabled)' if REMINDER_INTERVAL == -1 else ''}")

    parsed = fetch_metrics()
    if parsed is None:
        logger.error("Failed to fetch initial metrics, exiting")
        return

    up_count = sum(1 for d in parsed.values() if d["value"] == 1)
    down_count = len(parsed) - up_count
    logger.info(f"Initial state: {len(parsed)} monitors ({up_count} UP, {down_count} DOWN)")

    previous_states = {mid: d["value"] for mid, d in parsed.items()}

    await send_initial_state(parsed)

    loops = [check_loop()]
    if REMINDER_INTERVAL != -1:
        loops.append(reminder_loop())

    await asyncio.gather(*loops)


if __name__ == "__main__":
    asyncio.run(main())
